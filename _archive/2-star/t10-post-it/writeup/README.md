
The logic is pretty clear with a decompiler. The flag is decrypted via a key (using xor, basically a one time pad), which the ith key is generated from the following:

1. Compute nth fibonacci number, where n = key[i]. The fibonacci is computed by mod 1000000000000000003.
2. Using the computed result, call srand(result % 0xFFFFFFFF).
3. The ith xor key byte is rand() % 256.
4. The ith flag character is generated by flag[i] xor ith key byte.

With those in mind, you can easily generate the flag by writing a C program. The "key" array and encrypted "flag" array is easily found in decompiler (or even gdb).

(The program is not stripped, so you can easily see the symbol and using them in debugger.)

e.g. in gdb:
```
gef> print (char[68])flag
$1 =   "\270$9GH\337,\361\217\340\363\227p˕\316x\353\343\257\341\370\202\b\352g\"J,\275\266?.1N8\302\220\207<eV䐀\334|+\\\004_\360\221\227\032\223Q\251\021\032۟$\256\b\272\312,"

gef> print (int[68])key
$7 =   {[0x0] = 0xc6f0,
  [0x1] = 0x9f2d,
  [0x2] = 0x255d,
  [0x3] = 0xb413,
  [0x4] = 0xa336,
  [0x5] = 0x355f,
  [0x6] = 0x6d2b,
  [0x7] = 0xef70,
  [0x8] = 0x7229,
  [0x9] = 0x33e3,
  [0xa] = 0x9236,
  [0xb] = 0xc62b,
  [0xc] = 0x7c33,
  [0xd] = 0xdf8,
  [0xe] = 0x7673,
  [0xf] = 0xc464,
  [0x10] = 0xad84,
  [0x11] = 0xafe9,
  [0x12] = 0x1811,
  [0x13] = 0x923a,
  [0x14] = 0xa95a,
  [0x15] = 0x9111,
  [0x16] = 0x65cf,
  [0x17] = 0xd872,
  [0x18] = 0x455d,
  [0x19] = 0x144d,
  [0x1a] = 0x2901,
  [0x1b] = 0xff19,
  [0x1c] = 0x8d5e,
  [0x1d] = 0x2575,
  [0x1e] = 0x42f3,
  [0x1f] = 0xf695,
  [0x20] = 0x6646,
  [0x21] = 0x5961,
  [0x22] = 0xf611,
  [0x23] = 0x4c55,
  [0x24] = 0x8517,
  [0x25] = 0x2278,
  [0x26] = 0xa962,
  [0x27] = 0x3b97,
  [0x28] = 0xd15d,
  [0x29] = 0xb178,
  [0x2a] = 0xde7a,
  [0x2b] = 0x8166,
  [0x2c] = 0x814b,
  [0x2d] = 0x3273,
  [0x2e] = 0xe0c4,
  [0x2f] = 0xbd8e,
  [0x30] = 0x9556,
  [0x31] = 0x8c6,
  [0x32] = 0xa340,
  [0x33] = 0xab43,
  [0x34] = 0xf222,
  [0x35] = 0x6693,
  [0x36] = 0x71c,
  [0x37] = 0x8e14,
  [0x38] = 0x956e,
  [0x39] = 0xdbf4,
  [0x3a] = 0x3b6,
  [0x3b] = 0x1b7d,
  [0x3c] = 0x5b7e,
  [0x3d] = 0x8482,
  [0x3e] = 0xa120,
  [0x3f] = 0xf919,
  [0x40] = 0xc580,
  [0x41] = 0x322e,
  [0x42] = 0x6b02,
  [0x43] = 0xa8d4}
```

For the fibonacci number generation, it is well known that it cannot be directly done with recursion (as in the given program). You may use different approach for computing the numbers,
but the easiest way is to do it iteratively (just like what you will do if you are asked to compute fibonacci numbers)

```c
#define MOD 1000000000000000003U
unsigned long long fib(unsigned int i) {
    if (i == 0) {
        return 0;
    }
    unsigned long long prev = 0, val = 1;
    i--;
    for (unsigned int j = 0; j < i; j++) {
        unsigned long long tmp = val;
        val = (val + prev) % MOD;
        prev = tmp;
    }
    return val % MOD;
}
```

This way you can avoid doing recursion, which do not make use of memoization (also why this chall is called post-it), and may explode the stack.

The solution in c is in solve.c.
